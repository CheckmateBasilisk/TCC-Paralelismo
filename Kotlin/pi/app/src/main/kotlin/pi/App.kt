/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package pi

import kotlin.math.pow
import kotlin.system.measureTimeMillis
import kotlinx.coroutines.*

fun main(args: Array<String>) {
    val nIter : Int = 100_000_000 // 10m iterations
    val nThreads : Int = args[0].toInt() // arg[0] isnt the program name, it is the actual first argument

    val elapsed = measureTimeMillis {
        if (nThreads == 0) {
                println(pi(nIter))
            } else {
                println(pi_thread_coroutine(nIter, nThreads))
            }
    }

    println("${elapsed.toDouble()/1000}") //elapsed time must be in seconds


}

// pi_threaded is runBlocking{} , so it won't end until all children coroutines end
fun pi_thread_coroutine(maxIter: Int, nThreads: Int) : Double  {
    val threads = ArrayList<Deferred<Double>>() //list of thread handles
    var result : Double = 0.0

    runBlocking {
        for(i in 0..nThreads-1){ // ranges are inclusive in Kotlin
            //threads.add( async(newSingleThreadContext(i.toString()) ) { //newSingleThreadContext spawns a whole new thread, which is super expensive, but guarantees a thread for this coroutine to be executed on
            threads.add( async(Dispatchers.Default) { //the coroutine is passed to the dispachers.default thread (akin to a threadpool)
                pi_part(i*maxIter/nThreads,(i+1)*maxIter/nThreads) } )
        }
        for (t in threads){
            result += t.await()
        }
    }

    return result
}

suspend fun pi_part(start: Int, maxIter: Int) : Double {
    var result: Double  = 0.0

    for (i in start..maxIter) {
        result += 4 * (-1.0).pow(i) * 1/(i*2+1)
    }

    return result
}

fun pi(maxIter: Int) : Double {
    var result: Double  = 0.0

    for (i in 0..maxIter) {
        result += 4 * (-1.0).pow(i) * 1/(i*2+1)
    }

    return result
}
