/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */

// kotlinc hello.kt -include-runtime -d hello.jar
// java -jar hello.jar

package matrix

import kotlin.random.Random
import kotlin.system.measureTimeMillis
import kotlinx.coroutines.*

fun main(args: Array<String>) {
    val n : Int = 1000 // nxn matrices
    val nThreads: Int = args[0].toInt() // arg[0] isnt the program name, it is the actual first argument
    val min = -10
    val max = 10
    val m1 : Array<IntArray> = getRandomMatrix(n, min, max+1) //randomMatrix generates in [min, max[
    val m2 : Array<IntArray> = getRandomMatrix(n, min, max+1)
    var result : Array<IntArray> = Array(n) { IntArray(n) { 0 } }//matrix filled with 0s

    val elapsed = measureTimeMillis {
        if (nThreads == 0) {
                matrix(m1, m2, result)
            } else {
                matrix_thread(m1, m2, result, nThreads)
            }
    }

    println("${elapsed.toDouble()/1000}") //elapsed time must be in seconds
}

fun getRandomMatrix(n:Int , min: Int, max: Int): Array<IntArray> {
    val m = Array(n) { IntArray(n) { Random.nextInt(min, max) } } //creates an array of IntArrays
    return m; //immutability ends with scope?
}

fun matrix(m1: Array<IntArray>, m2: Array<IntArray>, result: Array<IntArray>) {
    for (i in 0..result.size-1) { //kotlin ranges are inclusive!
        for (j in 0..result[i].size-1) {
            for (k in 0..result.size-1) {
                result[i][j] += m1[i][k] * m2[k][j]
            }
        }
    }

}

fun matrix_thread(m1: Array<IntArray>, m2: Array<IntArray>, result: Array<IntArray>, nThreads: Int){
    // doesnt use thread hanldes as there's nothing to return and results are stored in shared memory
    runBlocking {
        for(t in 0..nThreads-1){
            //starting coroutines
            launch(Dispatchers.Default) { //the coroutine is passed to the dispachers.default thread (akin to a threadpool)
                //splitting the workload in the rows

                //FIXME: bug, os pedaços estão errados, algumas linhas são computadas duas vezes se o número de linhas não é divisível pelo número de threads
                // não deve ser problema pro benchmark, já que são 1000 linhas etc... é um incremento insignificante pro workload
                //println("thread ${t}, range: ${t*(result.size)/nThreads}..${((t+1)*(result.size-1)/nThreads)}")
                for (i in (t*(result.size)/nThreads)..((t+1)*(result.size-1)/nThreads)) { //kotlin ranges are inclusive!
                    for (j in 0..result[i].size-1) {
                        for (k in 0..result.size-1) {
                            result[i][j] += m1[i][k] * m2[k][j]
                        }
                    }
                }
            }
            //
        }
    }
}

fun printMatrix(m : Array<IntArray>){
    for (i in m.indices) {
        println(m[i].contentToString())
    }
}
